One of the challenges of deploying your code, your set of Python scripts, to run on other systems, is to communicate exactly what you depend upon, so that you make sure that that system has the right things installed.
We saw that virtual environments allow you to control this, but how do you state it, how do you help someone grabbing your library or your app know what they've got to install? Let's look at that.
Over here I have a little app, it's going to do some downloading and it's using 3 packages, now these would be interspersed throughout your app of course, right, but in this case, we just have them listed here.
So we are using a request to download some the homepage in Google, show the status code, imagine somewhere else using records for SQL, over here we are using user accounts and correct hashing with passlib and so on.
So if I run this in PyCharm, on my system, it works great, I've got 200 back from Google.
Let's imagine I was going to take the same code and run it somewhere else; to simulate running it on another machine, let me go to that virtual environment we created before and I'll just activate it, so I'll say ".user/screencaster/python_environments" this is what I created, I'll say "activate", OK the prompt changes, now if I say "pip list", you'll see I don't have all the things we need, I do have requests but I don't have records or passlib, let me see what happens if I try to run that program.
So we are going to run it and oh, that didn't go so well, I guess we needed records, we would go "pip install records" and we tried again, we'd see passlib and that's because- and that would be actually the easy case because it's all in one file, but normally, it would be spread out so eventually you would get to some action that import a module that "oh, well that crashes too" because there is some other missing piece.
So how do we solve this? It's quite simple, we can come over here and I would put whatever my code is, I want to run, I would give it a requirements.txt.
and in here, the format is super simple, you just list the names, one per line, of the packages you depend upon, so if I copy this and I come back over to my "other system" where I have, remember, I am using this pip from here, if I say "pip install -r" for requirements file and I give it that, it's going to look at all the requirements we've specified, download them, and make sure the system is ready to roll.
As long as I have kept that requirements file, up to date with what my app actually uses, we're good.
And PyCharm if we are working in certain types of environments, actually is really good about managing that for us, if it sees you work inside of a package like say a pyramid web app, and it sees you using some external package, that is not listed in your setup install requirements it'll actually automatically put them there for you.
OK, so now if we say "pip list", this looks like a much better chance, let's try running our little app again, we should just see 200 as it talks to Google and gets good response code, server says: 200.
So that's the requirement.txt file, add all of your requirements to it, just one package name per line and then "pip install -r requirements.txt".
In a graphic, our app is using some external modules, or external packages, here we are just showing requests, in order for this script to run at all, we are going to need a request installed on the system that's going to be running it.
How do we communicate that? Well, we have our requirements.txt that lists out our various requirements, then we "pip install -r", give it the requirements text file and boom, problem solved.
Now that we've got more or less obvious PEP 8 items out of the way, let's talk about a handful of what I consider foundational items.
They don't fit neatly into some classification like loops, or classes or something like that, but they are really important so I put them at the beginning.
The first thing I want to talk about is what I am calling truthiness, the ability to take some kind of symbol or object in Python and test it and have it tell us whether or not it should evaluate to be True or False.
So just to remind you in case you don't remember all the nuances of truthiness in Python, there is a list of things that are defined to be False, and then if it's not in this list, if it doesn't match one of the items on the list, it's considered to be True.
So obviously, the keyword "False" is False, empty sequences or collections, lists, dictionaries, sets, strings, those types of things, those are all considered to be False even though they are objects which are pointing to real live instances.
The numerical values zero integer and zero float are False, "None", that is the thing that represents pointing to nothing, is False and unlike other languages like say C where the null is actually defined to just be a sort of type def back to the zero, "None" is not zero but it's still considered to be False.
And if you have a custom type you can actually define its truthiness by in Python 3 defining a dunder bool, or Python 2 dunder non-zero.
All right, if you are not on that list, then whatever you are testing against is True.
Now let's just review, that's not Pythonic code per se, so let's see how this leads us to Pythonic behavior around testing for True and False.
All right, here I have a real basic method I call print truthiness, and let's just test it here, I can say print the truthiness of True and we could also test False I suppose, so if I run this, no surprise, True is True, False is False and you can see we are using this ternary statement here, "TRUE if" expression, "else FALSE".
Now we are not saying if expression == True, we are using the implicit truthiness of whatever it is that we are passing, here it's the True and False values, but it could also be a sequence, it could be some other kind of expression, all right.
So the recommendation for Pythonic tests on True/False like this is to do something along these lines, it's to actually use the truthiness inherent in the object itself, so you would say something like if I had a val, let's just say it's 7, I would say "if val" and down here I would do something, I wouldn't say "if value == True", or "if value is not equal to zero", I would just use the implicit truthiness that here is a number, if it's non-zero, which in theory I was testing for, it's True, otherwise it's False.
So let's see this for sequences, so if I have some sequence, let's make a list, it could be a dictionary or whatever, we could print the truthiness of empty list and we could have our sequence here, and you can see an empty list is False, but now if I add something and I run it again, and I test for the list with one item, then you can see, now it's coming out to be True.
You can see we can put in here numbers like zero, we can put in 11, or even -11, and zero of course is False, the others are True.
Now we can call this function print_truthiness on "None" as well, maybe leave a little comment here, we'll say "for none", if we pass None, it's going to evaluate to be False, this is not the best way if you are explicitly expecting None to test for it we'll talk about that as a separate item, finally we can define a class called a class or whatever you want to call it and maybe it's going to have some kind of internal collection, we'd like to surface that so we could use the instance of this class itself in a sort of truthiness way, so down here we'll give it some data like a list here, we'll give it the ability to add an item to its set and then we'll go over here and since it's Python 3, we are going to define dunder bool and here for bool we can define one of these ternary statements, we can say "return True if self.data" and just leverage the truthiness of data itself, "else return False".
And then once we do this, we can come down here and say "a = AClass()", we can print and of course if we run it empty, we would expect it to be False, and there it is, it's False, now if we add and item to it and we print it again, now it evaluates to True.
So the Pythonic expectation here or the Pythonic style is when you are testing objects, leverage their implicit truthiness, now we'll write something like "this is True if the length of data is greater than zero." Now, we don't want to write that, we just want to say "if data", it has an implicit truthiness and we are going to leverage that.
So here you can see we've got basically the same code, True if the expression evaluates to True, via its implicit truthiness, else we'll state False, we've got empty collection and it evaluates to False.
We add something to the collection and it evaluates to True, however notice we can't actually test the data equal to True so we can't say print me the truthiness of "data == True" because that's False, these are not the same things, you are basically comparing a list to a singleton True value, a boolean which never is going to be equal, so it's always going to say False, but we can leverage the truthiness of data and it will come back as True.
Finally, if we are going to create a custom type that is itself imbued with truthiness, we give it a dunder bool method and then we just return True or False, depending on how we want it to behave.
You can see below our empty version is False, our non-empty version is True.
In Python, there is no function or method overloading.
Here we have two methods called simple on this class, now the first one takes no parameters, the second one takes a details parameter, in some languages, these would be two distinct methods and based on the particular signature you are trying to use, the compiler would select one or the other.
This does not exist in Python, let's look at it in an example.
Here we have the same basic code and we are creating what I call the Sample class, that really doesn't mean anything, and we are going to call a simple method on it, notice we have this kind, we have this kind.
PyCharm is giving us a little bit of clue that something is going wrong here, you can see it's highlighting the second simple on line 6 but let's go ahead and run it and just see what happens.
So look, the first one where we pass some details, this actually worked, I call this simple with details and it said "Some details." However the second one didn't work, "simple() is missing 1 required parameter: 'details'", so what's going on here? It turns out there can only be one method called "simple" on this class, and so when we define the second one we basically eject this one from the class, we just overwrite it in a dictionary that the key "simple" now means something different, and so even though PyCharm is little bit freaked out by this here because it were doing it wrong above, did catch that error, this is the one that is actually not going to work because as far as this class is concerned, there is no method "simple" that takes no parameters, oh look, in the subsequent sections on how Python deals with this, because this kind of flexibility is super powerful and Python does support it, it just doesn't support it in the traditional method overloading way that you might be familiar with coming from C++, Java, C# and so on.
In a graphic, here it is.
Here is our class, we have the two methods, the top method is being overwritten or ejected by the bottom one, these could just as well be functions and not methods it would have the same effect, but what is really important to notice is when I ran the code, it wasn't the fact the I was redefining "simple" that was actually causing the runtime problem, this code as it's on the screen here, this will run perfectly fine it just won't do what you think, so be very careful here.
So for example, if we create the "Sample" class, we call a "simple" method with details, the last one in our list that is going to work correctly, but the bottom one crashes because it no longer exists, basically.
Now, there is nothing specifically Pythonic about this, but this lays out the problem the next 3 or 4 lectures are going to show us Pythonic ways to solve this problem that do not have to do with method overloading and signature matching.
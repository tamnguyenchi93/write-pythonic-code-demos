So let's just take a few minutes and review what we have studied and what we've learned.
We started out looking at PEP 8 and many people when they first start looking at Pythonic code and thinking about these idioms and these concepts, they might feel that, well, PEP 8 is what is Pythonic code, it defines how we write Pythonic code.
Yes it does touch on some of the things you should do in Python, it does talk about how you should write your code and even some of the underlying patterns that you use, but there is so much more, as you now know.
We talked about many foundational concepts and in some senses it's just kind of a grouping of a really important core concepts that didn't fit into their own category.
So we talked about thruthiness, booleans, leveraging the truthiness of objects, testing for None, remember, use "is", not "== None", we talked about multiple tests against the single value, remember we saw that Pythonic way to do this is value "in" collection or set of options, using "random.choice" to find a random item out of a sequence; we talked about string formatting, we saw that when you write scripts that are meant to be run as programs and chained together Unix style, you should really add exit codes for the error conditions, and we also saw flat is better than nested, in practice.
We next turned our attention to dictionaries and you saw a dictionary is really a core part of the Python language.
You saw there were tremendous performance benefits for using dictionaries for random lookup by values other than the index compared to other collection types such as list.
We saw that using __slots__ in certain limited situations can dramatically improve Python's performance around memory.
Python 3.5 introduced a new way to merge dictionaries, we saw that dictionaries can be a stand-in for switch statements, and we saw that dictionaries are isomorphic to JSON.
Then we turned our attention to generators and collections, generators as in methods using the yied keyword as well as generator expressions using the parentheses instead of the square brackets like a list comprehension.
We talked about using "in" to test for whether an item is in a collection or not, we saw slicing is a core Pythonic concept and can even be applied to outside of basic sequences like lists and so on, to things like databases.
For methods we saw that "yield" and "yield return" let us write simple and highly efficient generator methods; and finally, we saw that if we have a generator, regardless of where it comes from, whether it's a generator method or a generator expression, we saw a cool trick for summing up or counting the number of items in a generator.
One of the core building blocks for Python of course is functions.
And we saw the functions are first class citizens we saw that lambda expressions let us write small concise functions to be passed around as arguments, we talked about how using return values as errors from functions, while sometimes OK is generally, as a rule of thumb, frowned upon, and we should use errors and exception handling rather than return types to indicate failure, we talked about different ways to add polymorphism or overloading to functions, we talked about default values, variable number of arguments, keyword arguments, mapping dictionaries to and from keyword arguments all those sorts of things, and finally we saw one of the Python gotchas of which there is not many, but using a mutable instance or a mutable type for a default value.
Next, we came to import antigravity, talked about how amazing packages are and what the idioms around using packages and your own modules are in Python.
So remember, try to avoid wildcard imports, "from package import *", not super-Pythonic.
If you are building a module that is meant to be reused but also sometimes run as a program, you saw the "main", the __main__ convention in action.
We also briefly touched on virtual environments, using requirements.txt to help the consumer of your application know what they need to install.
Moving from functional programming into object-oriented programming we saw that classes and object oriented programming in Python are very important, and a key cornerstone of the language, we saw the right and the wrong way to add fields to the classes, we talked about data encapsulation and data hiding with underscore field name being protected and double underscore field name actually getting mangled by the Python runtime so that it's effectively private, although you saw that it's not really super hidden, you can still get to it.
And we saw that properties, both read-only and read/write are very powerful ways to encapsulate and protect our data and let the class manage it more itself.
Loops in Python are interesting because they are fairly different than most other languages, we saw there is no numerical "for" loop, there is only a sequence based "for...in" loop, but there are things to add into there, sequences we can use that will give us variants that are basically numerical "for" loops.
So remember we can "for...in" over a range and that will give us numbers in sequence, if we have a sequence and we want to "for...in" over that and get the index, we enumerate over that and project or unpack that into the tuple "index, value" and then we work with that.
We also saw that loops have an "else" block but we should forget that fact.
Tuples are powerful lightweight containers often used in Python.
And, we saw that we can unpack those into variables, so let's do something like "x,y =" tuple of length 2, put the first item in "x" and the second item in "y" and so on, and we can use that for all sorts of cool tricks, we'll use that when we do a "for...in" loop over enumerate, we used that if we wanted simulate returning multiple values from a method, remember, technically that's not what happens, but that's how it appears in code, which is wonderful; we finally saw that while tuples are great, working with them can be error-prone and kind of unclear, so upgrading them to named tuples via "collection.namedtuple" is a really nice way to work with them.
Finally, we took a look around the ecosystem for Python and said "there are so many amazing packages outside of Python", let's just round out the course by making a point that you should first look to things like PyPi, the Python package index and GitHub for the various building blocks or lego pieces of your application rather than trying to write them all from scratch.
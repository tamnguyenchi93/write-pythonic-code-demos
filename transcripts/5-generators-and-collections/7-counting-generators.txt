Now let's look at determining how many items are in a generator.
So if I have something like this, high measurements, and it's I am getting the value, looping over some collection called measurements, and I am doing a test, well, I actually have a really hard time knowing how many are in there, let's go look at that in PyCharm to see why.
So this is basically the same code that we used to talk about generator expressions in the first place, this time, this is set actually, fixed that, so here we have our high values, now if I try to print out the "len" of them, get the length, you can see PyCharm is already trying to tell me I am going down a bad path, but let's see what happens anyway.
Boom, object or type generator has no length, what might be wrong with getting the length, well it could be infinite, and it might take forever to determine that, but most importantly this is not going to work, all right? So we are not going to do that because it crashes, we could do something like this, we could say "create a list and pass into it the high values in them", if you pass a collection here, it will iterate overall the items and put it in the list and then I could print "len of list".
However, one of the beautiful things with generators is if even if there is a million items here, we only hold one in memory ever, well if we do this, we kind of undo that, we now have one million of them in memory but let's just see that it works, ta da, 4, OK, 4, that's cool, so we can use a combination of some really cool things, so if I had something like, let me just do something simple here, I'll say "sum" and say given any set of numbers, I could add them up, so those 3 numbers should have 7, we should see 7 down here, perfect, OK, so we can use sum to give it some kind of collection here, let me separate these, so we can kind of isolate them, count here and we'll say "count equals this", right, so we could add this up using sum, we could leverage this, along with another chained comprehension, so what do I want to put in here, for every item I see in here I would like to add one, because what I want to know is how many items not what is some of the values, so I could sum up the high values here, OK, now this actually broke, now this is worth knowing why did this break, so we have 4 and 0, obviously it should at least be 4 right, these are not 0 numbers that we saw, but here is the thing, unlike lists, once you run through a generator, it's done, you have to recreate it, so basically this, the fact that I did this used up the generator in a sense, you can only use them once, if you want to do it again you recreate it, if that's not going to work for you, create a list comprehension instead.
There you go, so 375, there is not 375 items in there, there is 4 so what I want to do is somehow in the best, most efficient possible way go through this list and say "for every time I find an item, give me one", so what I can do is I can create another generator, I can say "give me the number 1 for n in high values".
OK, so what we are going to do is we are going to through and say "every time you find a value, I don't care, I am not going to use this value", let's say 1, and that's going to add it up, now remember, it's very Pythonic to say "if I am not going to use a value, use this indicator say underscore", like here is a variable that has to come out and be stored somewhere but by saying underscore I have no any intention of using it, so we should get the answer 4.
Beautiful, so here we have our generator, you saw generators don't have a length, we can't use that, if we try to throw them into a list or something along those lines, that's not good because that undoes all the benefits of the generator, it loads everything in a memory all at once, so we can use this cool combination of the sum method and a chained generator expression, so the chained generator expression is "give me one for every time you find an item in high measurements", which is itself a generator, and then if we sum up that set, we actually get the number of items in the generator.
Remember, just be really careful it's used up after this, so if you want to run it again, you need to either recreate it by having the 5 lines above again, or turn into a list where you can reuse it over and over.
Here is a function called classic_fibonacci and what you do is you pass a limit to it and it will compute all the Fibonacci numbers up to that limit.
Notice we have a list called "nums" and it does all the work, fills this list up and once it's finally done, it gives you all the numbers.
Well, what if you want the first million Fibonacci, what if you need the first 5 million Fibonacci numbers, how long will this method take to run? What if you don't know how many you need, what if you want to start looking at them and you say well, I am looking for the time when I am going to the Fibonacci numbers and the second one is a prime number the third one is the cube of the first one in the sequence, who knows when that is, you are just looking through and you are going to decide "oh, now it matches, now I have got enough of these".
What if you were looking through this and you said "I am going to ask for 5 million Fibonacci numbers" and it was really the 5 millionth and first, right, maybe you just gave up.
So we are going to look at a different way to write exactly the same code that doesn't have these limitations, allows the consumers to process as much of these actually infinite series as it needs and yet does this in a very much on demand, high performance way.
This concept is called generators and it has this keyword called yield.
So let's look at this in code.
So, here is that same function, we can run it, it shows you the first few numbers in the Fibonacci sequence we are passing a limit here, we are passing a 100 so we want just the first set of Fibonacci numbers less than a 100.
So this is fine, but let's see if we can do better.
Before we move on, let's actually debug this a little bit.
So I am going to put a break point here, we are going to step into this, all right, so here we are and let's step into this method, and now we are stepping along, stepping along, and notice we are going through the list, you can see up here it actually shows you the list being built, it shows you the numbers so PyCharm is really cool in that sense, you can see the list growing, but notice we are the whole time staying here until we get to the limit of 100 which happens pretty soon here, right now, and then, we are going through them and processing you can "m" is the various values here.
So that's fine for small numbers, but what like I said, in the beginning, what if we don't know what the upper bound is? Or what if we have to put a really huge number here, what do you think happens to the memory consumption as that number grows, obviously we have to gather all the numbers that preceded it and hold them in memory all at once and then you get the answer.
So Python has this really cool keyword called "yield", and let's come down here and let's call this a generator_fibonacci, so we are going to do a few things, that if you have seen this before, you know it's pretty straightforward, if you've not seen this, it'll probably blow your mind.
All right, so what we are going to do is we are going to say instead of having this limit, we would like to work on the infinite series, now if I just run this code, two things will happen, first of all it's going to crash in a hurry, even if for some reason it wouldn't crash, if we had like infinite memory, it will still never return, right? It's just going to keep adding this infinite series but of course it's going to run out of memory.
So in Python, we can do something both cleaner and better here, so what we can do is we can use this yield keyword, and yield is like return but instead of returning from the method, it just says "hey, I want to create a collection or a sequence and here is one of the items, and here is one of the items", so we'll yield "current".
So, that's cool, so that's going to actually generate - continue to yield the items, you might wonder well, how we ever get a value out of it? So let's go find out.
So we are going to do this, now if I run this, it won't crash or anything, it will just keep spitting up numbers, scrolling to the right until it kind of goes crazy, so this is an infinite sequence but as a consumer of the infinite sequence, I can decide "OK, I've had enough".
So what I will say here is let's say "if m is greater than 100", we can use the same test as we have on line 36, we can just break out of our loop, all right, so let's run this, we should see the same output, we do, right, classic and generator have the same output but if we go into debugger here, it's going to be all sorts of different, all right, so we step in, here we are in generator_fibonacci just like we were before and here is our "while True", now watch what happens as soon as we get the current, which is 1 and we say "yield", immediately we are back here, we printed it and now look where we return into that loop, we just kind of resume the method back here, see there is this back and forth, I'll do this a few times, notice now we are going to jump back into this one and that current is 3 and next is 5, this is like a state machine that remembers where it left off and can be resumed, but even though it's an infinite sequence, we don't generate all of them, it's more like on demand as you pull items out of it it will compute them, so only as much as you pull, you have to pay in terms of computation.
The other really cool benefit is nowhere are we adding this to a list so nowhere are we using, basically nowhere are we storing more than one item at memory at a time so memory is not a problem in this situation.
So these generators are really cool and all you have to do is use the yield keyword.
If you compared against classic_fibonacci, not only is it better performance, more flexible, generates all the numbers and so on, it's actually shorter and once you get your mind around yield, it's actually easier to understand.
So that's cool, we can also take down here, we can create a something like an even_generator() and if I were to pass some kind of set here, some kind of number generator like this, I could say "for n in numbers, if n % 2 == 0" our standard even test, we will say "yield n".
So given any set of numbers, whether this is a list or a generator, it doesn't matter, it doesn't care, it's going to pull the even ones out and then down here, I can define a method called even_fibonacci and we'll say something like this: "for n in even_generator()", and then we can give it generator_fibonacci and we can say "yield from this".
So this will let us compose these things so we can actually create pipelines from one to the next.
So let's run our even Fibonacci through here and we should get only the even numbers that are also coming from the Fibonacci set and remember, this is an infinite sequence because we are starting out with the innermost bit, an infinite sequence, which itself is a generator that will take as many items are there and pass them back.
But because we don't actually do the work on this part until we pull on it, and we don't do the work on this part until we pull on it, it goes something like this, pull here, that means go pull this, which pulls on this, which will pull on this piece, one item at a time and then when we decide down here we are done, we'll break out.
So look at this, we have the even Fibonacci numbers, and there is not many so 2, 8, and 144.
Here they are, brilliant.
If you want more, we can get more.
Want up to 10 000, no problem, there they are, 10 000; up to a million, there they are up to a million.
Boom, like that.
All right, so let's look at this in a graphic, remember, we already talked about our algorithm here, it's a perfect implementation of Fibonacci but it has the limitations where you have to say how many you want before you actually get a chance to look at the numbers, and you can't look at too many or you'll run out of memory if for some reason you had infinite memory, you'd run out of time.
We can switch to a simpler version using the yield keyword create this as a generator and it actually does no work until you start pulling on the generator.
More of what we saw that you can write multiple generators and compose them in a pipeline style which is really awesome especially in things like data science.
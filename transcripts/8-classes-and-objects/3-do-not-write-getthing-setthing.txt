One of the primary reasons people will write non-Pythonic code is they come from other languages that have other idioms and they just move their code over and make them work using the same former idioms and not really adopt the new Python ones.
So here we have some NotSoPythonicPet that we've been playing with, it's got some private fields - age and name, we'd like a way for us to get the name and get the age but not set it, here we wrote a get_name and get_age, so that you can get those.
But this is not Pythonic at all, and when you use the code, it's not pretty, it looks something like this, so here we create a NotSoPythonicPet, it's going to be a cow called Betsy who is 4 and we can say she is named such and such and is however many years old, so "cow.get_name", "cow.get_age".
It doesn't have to be this way, let's see how it should be.
All right, so here is the Betsy code again, not so Pythonic, we are doing this and this, let's go down to this PetSnake type that we are working with and do something different, do it better.
You should almost never write these getters and setters in Python, instead, the much more natural way to work with this would be to say "py.name", "py.age" as if they were a field, now this can be just accessing underlined variables, these could be computed like in a shopping cart you could say "cart.total" and maybe that just actually does a loop and adds up all of the items, but as a consumer, you don't want to think of these as functions, you want to think of them as just attributes of the class, right? So in Python, instead of writing those getters and setters, we can say come over here and say I'd like to have a function called "name" and this is going to return "self.__name", now if I try to run this code, and let's do the same for age, and if I come down here and I write this code, we are going to get something entirely unexpected, what do you get if you say the name of a function? Without parentheses, you get the bound method, bound to this object.
That's not what we wanted, so then we have to say this, and that's not so pretty, technically it works, but we are kind of back to the previous example that was names for our getters, so in Python we can use a decorator called a property decorator, from the built-ins, down here I can say actually this is not a regular method but a property and now if I say "py", well if I say it far enough down, "py.
name and age" you can see the little "p" by there, and if I access it like this, this actually just calls the function, beautiful, right, don't write getters, write this.
Suppose I want to be able to change the age but not the name, if we try to set the age, right now it's read-only, obviously, and it says can't set the attribute we've already got this read-only property called age but if we wanted to set the age, we can come down here and write another function called "age", that takes the value and we'll say "self.__age = value".
Now we give it another attribute up here, we say "age.setter", now this is less delightful than just add property but that's how it works.
So now we should be able to set the age and run it, first our snake is 6, then 7, so just to make it clear, these are actual function calls, not just changing the underline property, I'll do a print, there, so all right, two little prints that every time you execute this code, which could do anything we wanted to do, we just happen to be setting the underlined private field, it will print this and then when we get it will print that.
So here you can see, "Here is my pet snake", all we are getting is age, its name and age and such and such, setting the age, getting the age and so on.
And finally like I said, you can have computed properties, aren't really backed by underline store, so here I could say let's have "is_protected", we could do return True or False depending on how high the protection level is so we'll say, let's say "self.protected level value is greater than 5", so if it's greater than 5, the snake is protected.
if it's not then it's not, whatever that means.
so we'll just at the very end I'll print "py.is_protected" you can see this property read-only property, run that, no, the snake is not protected.
All right, so this is not based on just returning something, we can compute whatever we want to.
Properties are really useful, very Pythonic and I recommend that you make good use of them.
So let's see in a graphic how we evolve this, right, getter/setter - bad idea.
In our Pythonic pet, our PetSnake, we've got our age and name and here we are writing a property that says get me the read only version of the name and the read only version of the age.
We also saw we can make writers or setters for the properties, as well as computed properties that are not just returning underlined fields.
So with this in place, we can write as a consumer of the class, much more natural code.
If we create a pet, it's called "py" and its name is "py.name" and its age is "py.age".